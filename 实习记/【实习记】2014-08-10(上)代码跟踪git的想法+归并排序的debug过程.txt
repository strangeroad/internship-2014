(冒泡，选择，插入，希尔，快速，归并，堆排)
周末加班学习C++，打算用C++写七大经典排序代码。
发现3个月前自己写的七大经典排序代码(C Language)突然运行出错。

Makefile内容
testmysort: testmysort.c mysortlib.c mysortlib.h
# gcc testmysort.c mysortlib.c -o testmysort
	gcc $< mysortlib.c -o $@
	./$@
直接make几次总是core dumped错误。

这时我用git已有快一年经验，当时就后悔没用git来跟踪代码变化。如果用git，只要git diff 就可以快速定位导致影响的代码。
git真的是一个好工具，一次又一次发现。
我想以后我的代码都要这样管理。

没办法，自己debug，看代码，多谢前面自己做到工作，本来就输出了很多有用的消息，竟然没动用gdb。
1、定位问题，#define sortfunc _msort可知与归并排序函数有关，换成_qsort测试没问题，因此肯定_msort()有问题。
2、排除问题：问题在一个地方，合并时的条件判断出错了！debug过程在源码中有记录，改5次后成功。

void _msort(int arr[], int len)
{/* 2014-03-26 一次写好就对！！？？？==>>那是错觉@2014-08-10@*/
    if (len<10){
        _isort(arr, len);
        return;
    }
    /* sorting each half part */
    int m = len/2;
    _msort(arr, m);
    _msort(arr+m, len-m);

    /* merge, use memery outside */
    int *arrtmp = (int*)malloc(len*sizeof(int));
    int i=0,j=m,k=0;    /* i是前游标，j是后游标，k申请内存的游标*/
    for (k=0;k<len;k++){
        /* bug v1 发现排序结果是规则的波峰型
         * 偶尔运行时core dumped
        if (arr[i]<arr[j]){
            arrtmp[k] = arr[i++];
        }else{
            arrtmp[k] = arr[j++];
        }
         */
        /* bug v2 不全面(i<m && arr[i]>=arr[j] 条件下：如果j>=m，也该执行分支一)
         * 偶尔运行时core dumped
        if (i<m && arr[i]<arr[j]){
            arrtmp[k] = arr[i++];
        }else{
            arrtmp[k] = arr[j++];
        }
         */
        /* bug v3 已接近正确，仅错在j>=m，一开始没发现
        if (j>=m || i<m && arr[i]<arr[j]){
            arrtmp[k] = arr[i++];
        }else{
            arrtmp[k] = arr[j++];
        }
         */
        /* bug v4 括号没改变逻辑 
        if (j>=m || (i<m && arr[i]<arr[j])){
            arrtmp[k] = arr[i++];
        }else{
            arrtmp[k] = arr[j++];
        }
         */
        /* 总结：
         * 一、if中的两分支具有*互换性*，所以地位相等，推出走每个分支的期望必须都是1/2。
         * 二、概率公式：P(A或B) = P(A) + P(B) - P(A且B)
         * 三、考虑到隐藏的附加条件：j>=len与i>=m不可同时成立，推出j>=len时必i<m，同理i>=m时必j<len
         */
        if (j>=len || (i<m && arr[i]<arr[j])){
            arrtmp[k] = arr[i++];   /* 走此路概率：1/2+1/2*1/2-1/2*1/2 = 1/2 */
        }else{              /* 等价：if (i>=m || (j<len && arr[i]>= arr[j])) */
            arrtmp[k] = arr[j++];
        }
    }
    for (k=0;k<len;k++){
        arr[k] = arrtmp[k];
    }
    free(arrtmp);
}

3、testmysort.c是个辅助测试的模块，调用mysortlib.c中的函数，通过宏#define sortfunc ×××每次测试一个。输出信息对估量排序函数有比较大的帮助。
输出类似如下：
< [ 35687,3377,49990,58351,12237 ]
> [ 3377,12237,35687,49990,58351 ]
---------------------------------
< [ 35687,3377,49990,58351,12237,64841,62230,41585,52580,18926 ]
> [ 3377,12237,18926,35687,41585,49990,52580,58351,62230,64841 ]
---------------------------------
< [ 35687,3377,49990,58351,12237,64841,62230,41585,52580,18926,46382,40611,49858,20665,2984,60676,24442,59752,8288,21844 ]
> [ 2984,3377,8288,12237,18926,20665,21844,24442,35687,40611,41585,46382,49858,49990,52580,58351,59752,60676,62230,64841 ]
---------------------------------
< [ 35687,3377,49990,58351,12237,64841,62230,41585,52580,18926,46382,40611,49858,20665,2984,60676,24442,59752,8288,21844,51890,13460,36039,20282,49485,9391,25777,41009,52448,1089,7594,22600,4466,57585,15416,49470,24123,12112,25521,43935 ]
> [ 1089,2984,3377,4466,7594,8288,9391,12112,12237,13460,15416,18926,20282,20665,21844,22600,24123,24442,25521,25777,35687,36039,40611,41009,41585,43935,46382,49470,49485,49858,49990,51890,52448,52580,57585,58351,59752,60676,62230,64841 ]
---------------------------------
sorted   1000000 used:   0.327s
sorted   2000000 used:   0.676s
sorted   4000000 used:   1.398s
sorted   8000000 used:   2.883s
sorted   1000000 used:   0.176s when same
sorted   2000000 used:   0.371s when same
sorted   4000000 used:   0.782s when same
sorted   8000000 used:   1.639s when same
sorted   1000000 used:   0.176s (inc) | sort   1000000 used:   0.177s (desc)
sorted   2000000 used:   0.371s (inc) | sort   2000000 used:   0.371s (desc)
sorted   4000000 used:   0.780s (inc) | sort   4000000 used:   0.779s (desc)
sorted   8000000 used:   1.639s (inc) | sort   8000000 used:   1.635s (desc)






4、最后git commit好，心里比较踏实了。

